# 의식의 흐름대로 진행하는 Python 문법 기초

## 1. Python 시작하기
<p>
파이썬은 1990년 귀도 반 로섬(Guido Van Rossum)이 개발한 인터프리터이다.</br>
귀도 반 로섬은 현재 구글 개발자(2017년 기준)로 근무하고 있다.</br>
물론 파이썬이라는 언어는 구글에 취업되기 전 개발한 언어이다.</br>
</p>
</p>
한 언어의 창시자이지만 현직 개발자이기 때문에 웃지 못할 헤프닝이 많다.</br>
귀도 반 로섬의 다양한 파이선 프로젝트를 보고 파이썬 개발 가능한 개발자를 뽑는다며</br>
파이썬을 얼마나 잘 다루는지 알려달라는 메일을 자주 받는다는 일화가...</br>
</p>
파이썬은 교육용으로 아주 인기가 있으나, 현재는 현직에서도 많이 사용되는 추세이다.</br>
대표적인 예가 구글이다. 구글에서 만들어지는 소프트웨어의 50%는 파이썬이라는 루머가 돌기도 한다.</br>
드롭박스 또한 파이썬을 사용한다.</br>
</p>

그렇다면 파이썬은 어떤 언어일까?

- 파이썬은 가장 인간다운 언어이다.

간단한 코드 하나를 예를 들어보자
<pre>
if 'tomato' in ['apple', 'melon', 'tomato', 'banana']: print('tomato') 
</pre>

위의 코드를 영어로 읽으면 다음과 같다.
<p>'만약 토마토가 \[사과, 수박, 토마토, 바나나\] 중에 있다면 토마토를 출력해라.'</p>
</br>
- 파이썬은 쉽다.

파이썬은 문법 자체가 아주 쉽고 간결하며 사람의 언어와 아주 닮아있다.

물론 영어권 사람들의 이야기이지만 영어와 비슷하다는점에서 매력을 느끼는 사람은 많을 것이다.

개인적으로 파이썬의 코드의 복잡도가 높아지면(짜는 사람의 능력에 따라 다르겠지만)

코드를 소설 읽는 수준으로 만들어버릴 수도 있는 언어라고 생각한다.

- 파이썬은 개발 속도가 빠르다.

파이썬은 인간의 영어와 매우 유사하므로 빠르게 배울 수 있다.

또한 인터프리터 언어 특성상 모르는건 바로 실행하볼 수 있다.

![인생은 짧기 때문에 파이썬이 필요해](http://devrel.qiniucdn.com/data/20140103005904/029_hooded_gray_o_1.jpg)

## 2. 설치

파이썬은 공식 홈페이지에서 설치파일을 다운로드받을 수 있다.

3.x 버전과 2.x버전은 많은 차이가 있다.

여기서는 3.x 기준으로 설명한다.

[파이썬 다운로드]((http://www.python.org/downloads))

윈도우는 설치파일을 설치하기만 하면 된다.

리눅스는 기본적으로 파이썬이 설치되어 있다.

python -V 명령어를 통해 어떤 파이썬이 설치되어 있는지 확인할 수 있다.

## 3. 파이썬 시작하기

### 1. 기초문법

#### 1) 사칙연산
파이썬 역시 다른 인터프리터 언어와 마찬가지로 대화형 인터프리터를 실행할 수 있다.

사칙연산을 수행해 보자
<pre>
>> 1 + 2
3
>> 3 / 2.4
1.25
>> 3 * 9
27
</pre>

#### 2) 자료형

파이썬은 자바스크립트와 마찬가지로 자료형이 감추어져 있다.

다만 파이썬은 자바스크립트와 달리 변수 선언과 사용에 차이점이 없다.

<pre>
>> a = 123
>> a
123
</pre>

파이썬에서 자료형을 확인하는 함수는 type()이다.

<pre>
>> type(a)
<class 'int'>
</pre>

##### [1] 숫자형(Number)
숫자 형태로 이루어진 자료형으로 정수, 실수를 이야기한다.

물론 파이썬 내부에서는 int, float, double등의 자료형을 나누지만 자세한건 다음에 알아보자.

숫자형의 연산은 다른 언어와 마찬가지지만 몇가지 다른 연산자가 있다. 하나하나 살펴보도록 하자.

사칙연산
 
<pre>
>> a = 1 # 변수선언
>> b = 2 # 변수선언
>> a + b # 덧셈 1 + 2
3
>> a - b # 뺄셈 1 - 2
-1
>> a * b # 곱셈 1 * 2
2
>> a / b # 나눗셈 1 / 2
0.5
>> a ** b # 제곱 1 ^ 2
1
>> a // b # 나눗셈 후 나온 결과값보다 작은정수 중 가장 큰 정수
0
>> -a // b # 음수일 때 주의해야 한다.
-1
</pre>

##### [2] 문자형(String)
파이썬에서 문자열을 만드는 방법은 다른 언어들과 달리 4가지나 있다.

<pre>
>> "Python is fun"
'Python is fun'
>> 'Python is fun'
'Python is fun'
>> """Python is fun"""
'Python is fun'
>> '''Python is fun'''
'Python is fun'
</pre> 

첫번째로 문자열 안에 작은 따옴표를 포함시키고 싶다.
<pre>
>> "Python is 'fun'"
"Python is 'fun'"
</pre>

두번째로 문자열 안에 큰 따옴표를 포함시키고 싶다.
<pre>
>> 'Python is "fun"'
'Python is "fun"'
</pre>

문자열 안에 작은 따옴표와 큰 따옴표를 모두 포함시키고 싶다.
<pre>
>> """"Python" is 'fun'"""
'"Python" is \'fun\''
</pre>

갑자기 없던 역슬래시가 나타났다.

예상한 대로 역슬래시를 이용하여 따옴표를 표시할 수도 있다.
<pre>
>> 'Python is \'fun\''
"Python is 'fun'"
</pre>

사실 따옴표 3개의 진짜 사용법은 줄바꿈을 지원한다는 것이다.
<pre>
>> """Python 
...is 
...fun"""
'Python\nis\nfun'
</pre>

줄바꿈 문자인 \n을 자동으로 붙여넣어준다.

어떻게 사용하던 작성자 마음에 방식대로 사용할 수 있다.

그렇다면 문자열 열산은 어떨까.

- 문자열 덧셈 (생각한 대로)

<pre>
>> a = "Python"
>> b = " is fun"
>> a + b
'Python is fun'
</pre>

- 문자열 곱셈 (주의! 문자열과 숫자는 곱할 수 있다.)

<pre>
>> a = "Python"
>> a * 2
'PythonPython'
</pre>
응용!!
<pre>
print("-" * 50)
print("Hello Python!!")
print("-" * 50)
</pre>
<pre>

--------------------------------------------------
Hello Python!!
--------------------------------------------------
</pre>

- 문자열 인덱싱

파이썬의 문자열 역시 배열로 이루어져 있어 인덱스로 문자를 검색할 수 있다.

배열이기 때문에 0부터 시작한다는 것 역시 같다.
<pre>
>>> a = 'Python is fun'
>>> a[3]
'h'
</pre>
문자열 인덱싱의 파이썬만의 큰 장점은 역 인덱싱이 가능하다는 것이다.

물론 역 인덱싱은 0부터 시작하지 않는다는것을 주의해야 한다.
<pre>
>>> a = 'Python is fun'
>>> a[-3]
'f'
</pre>

- 문자열 슬라이싱

문자열 슬라이싱이란 문자열을 자르는 방법이다.

위의 문자열 인덱싱과 역인덱싱을 통해 무궁무진한 방법으로 슬라이싱을 할 수 있다.

<pre>
>> message = "Life is too short, You need Python"
>> message[0:4]
'Life'
>> message[5:7]
'is'
>> message[5:-8]
'is too short, You nee'
</pre>

위의 예제만 봐도 대충 이해가 갈것이라고 생각된다.

규칙은 앞의 인덱스보다 크거나 같고 뒤의 인덱스보다 작다

그렇다면 한가지 불가능한게 있다.

<pre>
>> message[-6:-1]
'Pytho'
</pre>

역 인덱스 만으로는 맨 마지막 문자를 추출할수가 없다는 것이다.

그럴때는 인덱스를 생략하면 된다.

<pre>
>> message[-6:]
'Python'
>> message[5:]
'is too short, You need Python'
>> message[:-8]
'Life is too short, You nee'
>> message[:]
'Life is too short, You need Python'
</pre>

이 때 한가지 주의해야 할 게 있다.
문자열(배열)은 Immutable속성을 가지고 있어 직접 수정할 수 없다.
<pre>
>> message[5] = 'b'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
</pre>

수정이 필요할 때는 어떻게 해야 할까?<br/>
문자열 슬라이싱과 연산을 이용하면 된다.
<pre>
>> message[:5] + 'b' + message[6:]
'Life bs too short, You need Python'
</pre>

- 문자열 포메팅

문자열 슬라이싱과 연산을 이용하면 직관적이지도 않고 무언가 지저분해보인다.<br/>
내가 만들려는 문자열을 한눈에 보면서 문자열을 수정할 수 있는 방법이 필요하다.<br/>
그럴 때 문자열 포메팅을 사용하면 된다.
<pre>
>>> "Lise is too %s, You need Python" % "short"
'Life is too short, You need Python'
</pre>

이런 형식은 아래과 같은 경우 많이 사용된다.
<pre>
>>> version = "3.6"
>>> "Python %s RELEASE" % version
'Python 3.6 RELEASE'
</pre>

그렇다면 두개 이상의 값을 넣고 싶을 때에는 어떻게 할까?<br/>
뒤에서 배울 튜플이라는 자료형을 이용하여 넣어주면 된다.
<pre>
>>> version = "3.6"
>>> status = "RELEASE"
>>> "Python %s %s" % (version, status)
'Python 3.6 RELEASE'
</pre>

|코드|설명|
|:---:|:---|
|%s|문자열|
|%c|문자 1개|
|%d|정수|
|%f|부동소수|
|%o|8진수|
|%x|16진수|
|%%|특수문자 %|

여기서 특이사항 하나.<br/>
%s를 사용하면 어떤 변수가 들어오던 문자열로 변환해서 출력한다.<br/>
다음 예를 살펴보자

<pre>
>>> "Python %s RELEASE" % 3.6
'Python 3.6 RELEASE'
</pre>
<p>
이는 str(3.6)을 한 것과 같다.<br/>
str()함수는 다른 자료형을 문자열로 바꿔주는 함수이다.<br/>
type(3) 과 type(str(3))을 입력해보면 차이를 알 수 있다.<br/>
</p>
<p>
%%는 퍼센테이지를 표시하기 위해 사용된다.<br/>
아래와 같은 경우에 사용한다.<br/>
</p>
<pre>
>>> "Usage %d%%" % 99
'Usage 99%'
</pre>
만약 문자열을 표기할 자리수를 정하고 싶다면 %와 문자 사이에 자리수를 넣으면 된다.<br/>
<pre>
>>> "Usage %5d%%" % 99.99
'Usage    99%'
>>> "Usage %f%%" % 99.99
'Usage 99.990000%'
>>> "Usage %.2f%%" % 99.99
'Usage 99.99%'
>>> "Usage %.1f%%" % 99.99
'Usage 100.0%'
</pre>
재밌는 점은 소수점을 표기할 때에는 반올림을 한다는 점이다.<br/>
자세한건 인터프리터에서 여러가지 상황을 수행해보면서 알아보자.<br/>

- 문자열 함수

<pre>
>>> message = 'Life bs too short, You need Python'
>>> version = ' Python 3.6 '
</pre>

|함수|설명|
|:---:|:---|
|message.count(찾을문자열)|문자열 내에 포함된 문자열의 개수|
|message.find(찾을문자열)|문자열을 순차적으로 탐색하여 가장 먼저 매칭된 인덱스<br/>문자열이 없다면 -1|
|message.index(찾을문자열)|문자열을 순차적으로 탐색하여 가장 먼저 매칭된 인덱스<br/>문자열이 없다면 오류 발생|
|",".join(message)|모든 문자 사이에 문자열 삽입한다.|
|message.upper()|모든 문자를 대문자로 바꾼다.|
|message.lower()|모든 문자를 소문자로 바꾼다.|
|title.lstrip()|왼쪽 공백을 지운다.|
|title.rstrip()|오른쪽 공백을 지운다.|
|message.strip()|양쪽 공백을 지운다.|
|message.replace(바뀔문자열, 바꿀문자열)|특정 문자열을 바꾼다.|
|message.split(구분자)|구분자를 기준으로 문자를 나누어 배열로 반환한다.<br/>구분자가 없으면 공백을 기준으로 나눈다.|

##### [3] 리스트(List)

리스트 만드는 법
<pre>
>>> arr = [1, 2, 3, 4]
</pre>
파이썬의 리스트는 타입구분이 없다. 
<pre>
>>> arr = [1, '2', 'Three', [4, "Five"]]
</pre>
비어 있는 리스트 만들기 
<pre>
>>> arr = []
>>> arr = list()
</pre>

- 인덱싱과 슬라이싱

문자열처럼 인덱싱과 슬라이싱을 할 수 있다. 
<pre>
>>> a = [1, 2, 3, 4]
>>> a[0]
1
>>> a[0] + a[3]
5
>>> a[:2]
[1, 2]
>>> a[-1]
4
>>> a[-1:]
[4]
</pre>
문자열과는 다르게 값을 바꿀 수 있다.
<pre>
>>> a[1] = 5
[1, 5, 3, 4]
</pre>
슬라이싱을 이용하여 연속된 범위의 값을 바꿀수도 있다.
<pre>
>>> a[1:3] = ['a', 'b', 'c']
>>> a
[1, 'a', 'b', 'c', 4]
</pre>
인덱싱과 슬라이싱은 잘 구분해서 사용해야 한다.
<pre>
>>> a = [1, 2, 3, 4]
>>> a[1] = ['a', 'b', 'c']
[1, ['a', 'b', 'c'], 3, 4]
</pre>

- 리스트 연산자

리스트 더하기
<pre>
>>> a = [1, 2]
>>> b = [3, 4]
>>> a + b
[1, 2, 3, 4]
</pre>
리스트 곱하기
<pre>
>>> a = [1, 2]
>>> a * 3
[1, 2, 1, 2, 1, 2]
</pre>
리스트 곱하기
<pre>
>>> a = [1, 2]
>>> a * 3
[1, 2, 1, 2, 1, 2]
</pre>

- 리스트 함수

<pre>
>>> a = [1, 2, 3, 4]
</pre>
|함수|설명|
|:---:|:---|
|del(a[인덱스])|리스트의 요소를 삭제한다.|
|len(a)|리스트의 크기를 반환한다.|
|a.append(추가할값)|리스트의 마지막에 추가한다.|
|a.sort()|리스트의 요소를 순서대로 정렬한다.|
|a.reverse()|현재 리스트를 역순으로 뒤집는다.|
|a.index(찾을값)|찾고자 하는 값의 인덱스를 반환한다.<br/>값이 없으면 오류가 발생한다.|
|a.insert(위치, 값)|넣고자 하는 위치에 값을 넣어준다.|
|a.remove(값)|리스트에서 첫 번째로 나오는 값을 삭제한다.|
|a.pop()|리스트의 맨 마지막 요소를 삭제하고 삭제한 값을 반환한다.|
|a.count(찾을값)|리스트에서 찾고자 하는 값의 개수를 반환한다.|
|a.extend(리스트)|넣고자 하는 리스트를 리스트의 마지막에 이어붙인다.<br/>a = a + 리스트 와 같다.|

##### [4] 튜플(Tuple)

<p>
튜플은 아주 간단하게 Immutable List라고 생각하면 편하다.
</p>
튜플을 생성해보자
<pre>
>>> t1 = ()
>>> t2 = (1,)
>>> t3 = (1, 2)
>>> t4 = 1, 2, 3
>>> t5 = (1, 'b', 3)
</pre>
<p>
선언하는데 정신이 하나도 없다.<br/>
하나씩 천천히 살펴보자.<br/>
t1은 빈 튜플이다. 튜플은 수정이 불가능하므로 별로 의미는 없다.<br/>
t2는 뒤에 콤마가 들어가 있다. 값이 하나뿐인 튜플은 그냥 변수가 되므로 튜플로 지정해주기 위해서는 콤마를 추가해야 한다.<br/>
t3는 일반적인 선언방법이다.<br/>
t4는 괄호가 없다. 여러 값을 콤마로 구분해 하나의 변수에 넣으면 괄호가 없어도 튜플로 인식한다.<br/>
t5는 리스트처럼 다양한 형태의 값이 들어올 수 있다는 것을 보여준다.
</p>
튜플은 자주 수정이 일어나지 않는 READ_ONLY(스파크)환경에서 유리하다.<br/>

- 인덱싱과 슬라이싱

<p>
튜플도 인덱싱과 슬라이싱이 가능하다.<br/>
하지만 수정과 관련된 연산은 오류가 발생한다.
</p>
<pre>
>>> t1 = (1, 2, 'a', 'b')
>>> t1[0]
1
>>> t1[:2]
(1, 2)
</pre>

- 튜플 연산자

<p>
리스트와 마찬가지이다.<br/>
마찬가지로 수정과 관련된 연산은 오류가 발생한다.
</p>
<pre>
>>> t1 = (1, 2, 'a', 'b')
>>> t2 = (3, 4)
>>> t1 + t2
(1, 2, 'a', 'b', 3, 4)
>>> t1 * 3
(1, 2, 'a', 'b', 1, 2, 'a', 'b', 1, 2, 'a', 'b')
</pre>

##### [4] 딕셔너리(Dictionary)

<p>
일반적으로는 json을 생각하면 되고, 자바에서는 맵을 생각하면 된다.<br/>
key와 value를 한 쌍으로 가지는 key, value들의 집합이다.
</p>
딕셔너리를 생성해 보자
<pre>
>>> dic = {
... 'key1': 'value1',
... 'key2': 'value2',
... }
>>> dic
{'key1': 'value1', 'key2': 'value2'}
</pre>
딕셔너리에 들어갈 수 있는 자료형 역시 다양하다.
<pre>
>>> dic = {
... 1: 'a',
... 'b': 3.141592,
... 3: [1, 2, 3]
... }
>>> dic
{1: 'a', 'b': 3.141592, 3: [1, 2, 3]}
</pre>

- 자료의 추가/삭제

자료의 추가 삭제는 모두 키를 이용한다.<br/>
(사실 모든 접근을 키로 한다.)
<pre>
>>> dic = {}
>>> dic[1] = 'a'
>>> dic['b'] = [1, 2, 3]
>>> dic
{1: 'a', 'b': [1, 2, 3]}
>>> del(dic['b'])
>>> dic
{1: 'a'}
</pre>
자료의 접근/수정 역시 키를 이용한다.
<pre>
>>> dic['c'] = 55
>>> dic
{1: 'a', 'c': 55}
>>> dic[1] = 'kim'
>>> dic
{1: 'kim', 'c': 55}
>>> dic['c']
55
</pre>
참고로 딕셔너리는 자료의 순서가 없기 때문에 인덱싱과 슬라이싱은 불가능하다.<br/>
또한 딕셔너리의 키는 유일한 값이어야 하므로 동일한 키 값을 두개 넣으면 마지막에 들어 간 값이 이전 값을 덮어쓴다.<br/>

- 딕셔너리 함수
<pre>
>>> dic = {'Kim': 25, 'Lee': 20, 'Park': 24}
</pre>
|함수|설명|
|:---:|:---|
|dic.keys()|딕셔너리의 키값을 모아 dic_keys라는 객체를 반환한다.<br/>이 객체는 iterate를 지원한다.|
|dic.values()|딕셔너리의 값을 모아 dic_values라는 객체를 반환한다.<br/>이 객체는 iterate를 지원한다.|
|dic.items()|딕셔너리의 키 값 쌍을 튜플로 묶어 dic_items라는 객체로 반환한다.<br/>이 객체는 iterate를 지원한다.|
|dic.clear()|딕셔너리의 모든 키 값 쌍을 지운다.|
|dic.get(키값)|키가 가지는 값을 반환한다.<br/>키가 없으면 dic['a']는 오류를 발생하고, dic.get('a')는 None을 반환한다.|
|'Kim' in dic|딕셔너리 안에 'Kim'이라는 키값이 있는지 여부를 반환한다.<br/>함수라기보다는 연산자에 가깝다.|

##### [5] 집합(Set)

집합은 파이썬 2.3부터 지원하기 시작하였으며 집합 관련된 것들의 처리를 쉽게 하도록 만들어졌다.<br/>
집합을 생성해보자.
<pre>
>>> s1 = set([1, 2, 3])
>>> s1
{1, 2, 3}
>>> s2 = set('hello')
>>> s2
{'l', 'h', 'e', 'o'}
</pre>
결과가 딕셔너리와 비슷해 보이나 키, 값으로 구분되어 있지 않다.<br/>
보이는 그대로이다.<br/>
딕셔너리처럼 중복을 허용하지 않고 순서가 없다.<br/>
따라서 인덱싱과 슬라이싱을 지원하지 않는다.<br/>
하지만 리스트나 튜플로 변환하여 인덱싱이나 슬라이싱을 사용하기도 한다.
<pre>
>>> s1 = set([1, 2, 3])
>>> lsit(s1)
[1, 2, 3]
>>> tuple(s1)
(1, 2, 3)
</pre>
집합 자료형이 유용할 때는 교집합, 합집합, 차집합을 구할 때이다.
<pre>
>>> s1 = set([1, 2, 3, 4, 5])
>>> s2 = set([4, 5, 6, 7, 8])
</pre>
- 교집합
<pre>
>>> s1 & s2
{4, 5}
>>> s1.intersection(s2)
{4, 5}
</pre>
- 합집합
<pre>
>>> s1 | s2
{1, 2, 3, 4, 5, 6, 7, 8}
>>> s1.union(s2)
{1, 2, 3, 4, 5, 6, 7, 8}
</pre>
- 차집합
<pre>
>>> s1 - s2
{1, 2, 3}
>>> s1.difference(s2)
{1, 2, 3}
</pre>

- 집함 함수
<pre>
>>> s1 = set([1, 2, 3, 4, 5])
</pre>
|함수|설명|
|:---:|:---|
|s1.add(값)|집합에 값을 추가한다.|
|s1.update(리스트)|여러개의 값을 한꺼번에 추가한다.|
|s1.remove(값)|특정 값을 삭제한다.|

### 2. 제어문